#!@PYTHON@

#
# RINA Configuration Generator (frontend)
#
#    Francesco Salvestrini <f.salvestrini@nextworks.it>
#    Sander Vrijders       <sander.vrijders@intec.ugent.be>
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA  02110-1301  USA

import sys
import xml.dom.minidom
import argparse
import os.path
import datamodel as dm
import json

tag = "confgen-fe"

def debug(message):
    print(tag + ": " + message)

def error(message):
    print(tag + ": " + message)

# Holding global vars here

nodes = []
difs = []
links = []

#Auxiliary functions

def find_node(nodes, node_name):
    for node in nodes:
        if node.name == node_name:
            return node
    raise LookupError("Could not find node in known nodes list")

def find_dif(difs, dif_name):
    for dif in difs:
        if dif.name == dif_name:
            return dif
    raise LookupError("Could not find DIF in known DIFs list")

def parse_dif(dif):
        new_dif = dm.dif(dif.getAttribute("id"))
        new_dif.dif_type = dif.getAttribute("type")

        if new_dif.dif_type == "normal-ipc":
            new_dif.cdap_timeout = dif.getAttribute("cdapTimeoutInMs")
            new_dif.enroll_timeout = dif.getAttribute("enrollmentTimeoutInMs")
            new_dif.flow_alloc_timeout = dif.getAttribute("flowAllocatorTimeoutInMs")
            new_dif.watchdog_period = dif.getAttribute("watchdogPeriodInMs")
            new_dif.decl_dead_int = dif.getAttribute("declaredDeadIntervalInMs")
            new_dif.neigh_enroll_period = dif.getAttribute("neighborsEnrollerPeriodInMs")

            dtc = dif.getElementsByTagName("data-transfer-constants")[0]
            new_dtc = dm.dt_consts(dtc.getAttribute("addressLength"), \
                                   dtc.getAttribute("cepIdLength"), \
                                   dtc.getAttribute("lengthLength"), \
                                   dtc.getAttribute("portIdLength"), \
                                   dtc.getAttribute("qosIdLength"), \
                                   dtc.getAttribute("sequenceNumberLength"), \
                                   dtc.getAttribute("maxPduSize"), \
                                   dtc.getAttribute("maxPduLifetime"))
            new_dif.dt_consts = new_dtc

            # To be extended to include EFCP
            qoscubes = dif.getElementsByTagName("qos-cube")
            for qoscube in qoscubes:
                new_cube = dm.qos_cube(qoscube.getAttribute("id"), \
                                       qoscube.getAttribute("name"))
                new_cube.part_del = qoscube.getAttribute("partialDelivery")
                new_cube.ord_del = qoscube.getAttribute("orderedDelivery")
                new_dif.qos_cubes.append(new_cube)

            kias = dif.getElementsByTagName("known-ipcp-address")
            for kia in kias:
                new_name = dm.rina_name(kia.getAttribute("apName"), \
                                        kia.getAttribute("apInstance"))
                new_kia = dm.ipcp_address(new_name, \
                                          kia.getAttribute("address"))
                new_dif.known_ipcp_addr.append(new_kia)

            pft = dif.getElementsByTagName("pft-conf")[0]
            if not pft == "":
                pftp = pft.getElementsByTagName("pft-policy")[0]

                new_pft_conf = dm.pft_conf(pftp.getAttribute("name"), \
                                           pftp.getAttribute("version"))

                lsrc = pft.getElementsByTagName("link-state-routing-conf")[0]

                new_lsr_conf = dm.lsr_config(lsrc.getAttribute("objectMaximumAge"), \
                                             lsrc.getAttribute("waitUntilReadCDAP"), \
                                             lsrc.getAttribute("waitUntilError"), \
                                             lsrc.getAttribute("waitUntilPDUFTComputation"), \
                                             lsrc.getAttribute("waitUntilFSODBPropagation"), \
                                             lsrc.getAttribute("waitUntilAgeIncrement"), \
                                             lsrc.getAttribute("routingAlgorithm"))
                new_pft_conf.lsr_conf = new_lsr_conf
                new_dif.pft_conf = new_pft_conf

        difs.append(new_dif)

def parse_app(app):
    nodes_d = app.getElementsByTagName("node")
    for node in nodes_d:
        node_n = find_node(nodes, node.getAttribute("name"))

        new_name = dm.rina_name(app.getAttribute("ap-name"), \
                                app.getAttribute("ap-instance"))

        new_app = dm.app(new_name)

        registrations = node.getElementsByTagName("register")
        for reg in registrations:
            new_app.regs.append(str(reg.getAttribute("dif-name")))

        node_n.apps.append(new_app)

def parse_ipcps(node):
    ipcps = node.getElementsByTagName("ipcp")

    node_n = find_node(nodes, node.getAttribute("id"))

    for ipcp in ipcps:
        new_name = dm.rina_name(ipcp.getAttribute("ap-name"), \
                                ipcp.getAttribute("ap-instance"))
        new_ipcp = dm.ipcp(new_name)
        new_ipcp.dif_name = ipcp.getAttribute("dif")

        registrations = ipcp.getElementsByTagName("register-dif")
        for dif in registrations:
            new_ipcp.registrations.append(str(dif.getAttribute("name")))

    node_n.ipcps.append(new_ipcp)

def parse_node(node):
    new_node = dm.node(node.getAttribute("id"))

    interfaces = node.getElementsByTagName("interface")
    for interface in interfaces:
        new_int = dm.interface(interface.getAttribute("id"))
        new_int.ip = interface.getAttribute("ip")
        new_node.interfaces.append(new_int)

    nodes.append(new_node)

def parse_link(link):
    new_link = dm.link(link.getAttribute("id"))

    a = link.getElementsByTagName("from")[0]
    new_link.node_a = a.getAttribute("node")
    new_link.int_a = a.getAttribute("interface")

    b = link.getElementsByTagName("to")[0]
    new_link.node_b = b.getAttribute("node")
    new_link.int_b = b.getAttribute("interface")

    links.append(new_link)

#
# Main
#

topology_filename = "topology.xml"
ipcps_filename    = "ipcps.xml"
apps_filename     = "apps.xml"
difs_filename     = "difs.xml"
output_dir        = "configs"
input_dir         = "inputs"
prefix_name       = "ipcm"

try:
    parser = argparse.ArgumentParser(description='@PACKAGE_NAME@ (FE)',
                                     epilog='@PACKAGE_BUGREPORT@')
    parser.add_argument('--topology',
                        type=str,
                        metavar="FILE",
                        default=[ topology_filename ],
                        nargs=1,
                        help='the topology XML filename ' + \
                             '(default: %(default)s)')

    parser.add_argument('--ipcps',
                        type=str,
                        metavar="FILE",
                        default=[ ipcps_filename ],
                        nargs=1,
                        help='the IPC Process XML filename ' + \
                             '(default: %(default)s)')

    parser.add_argument('--apps',
                        type=str,
                        metavar="FILE",
                        default=[ apps_filename ],
                        nargs=1,
                        help='the applications XML filename ' + \
                             '(default: %(default)s)')

    parser.add_argument('--difs',
                        type=str,
                        metavar="FILE",
                        default=[ difs_filename ],
                        nargs=1,
                        help='the DIFs XML filename ' + \
                             '(default: %(default)s)')

    parser.add_argument('--output-dir',
                        type=str,
                        metavar="DIR",
                        default=[ output_dir ],
                        nargs=1,
                        help='the output dir of the XMLs ' + \
                             '(default: %(default)s)')

    parser.add_argument('--prefix',
                        type=str,
                        metavar="FILE",
                        default=[ prefix_name ],
                        nargs=1,
                        help='the prefix of the name of the output files ' + \
                             '(default: %(default)s)')

    parser.add_argument('--input-dir',
                        type=str,
                        metavar="DIR",
                        default=[ input_dir ],
                        nargs=1,
                        help='the input dir of the XMLs ' + \
                             '(default: %(default)s)')

    args = parser.parse_args()

    topology_filename = args.topology[0]
    ipcps_filename    = args.ipcps[0]
    apps_filename     = args.apps[0]
    difs_filename     = args.difs[0]
    output_dir        = args.output_dir[0]
    prefix_name       = args.prefix[0]
    input_dir         = args.input_dir[0]
except Exception as e:
    error("Cannot parse options: " + str(e))
    sys.exit(1)

debug("Input args:")
debug("  Topology   = " + str(topology_filename))
debug("  IPCPs      = " + str(ipcps_filename))
debug("  Apps       = " + str(apps_filename))
debug("  DIFs       = " + str(difs_filename))
debug("  Prefix     = " + str(prefix_name))
debug("  Output dir = " + str(output_dir))
debug("  Input dir  = " + str(input_dir))

try:
    impl = xml.dom.minidom.getDOMImplementation()

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    DOM_topology = xml.dom.minidom.parse(input_dir + "/" + topology_filename)

    debug("Parsing topology")

    topology = DOM_topology.documentElement
    assert topology.tagName == "topology"

    nodes_d = DOM_topology.getElementsByTagName("node")

    for node in nodes_d:
        parse_node(node)

    links_d = DOM_topology.getElementsByTagName("link")

    for link in links_d:
        parse_link(link)

    debug("Topology parsed successfully")

    DOM_ipcps = xml.dom.minidom.parse(input_dir + "/" + ipcps_filename)

    debug("Parsing ipcps")

    ipcps = DOM_ipcps.documentElement
    assert ipcps.tagName == "ipcps"

    nodes_d = DOM_ipcps.getElementsByTagName("node")

    for node in nodes_d:
        parse_ipcps(node)

    debug("IPCPs parsed successfully")

    DOM_apps = xml.dom.minidom.parse(input_dir + "/" + apps_filename)

    debug("Parsing apps")

    root = DOM_apps.documentElement
    assert root.tagName == "apps"

    apps = DOM_apps.getElementsByTagName("app")
    for app in apps:
        parse_app(app)
    debug("Apps parsed succesfully")

    DOM_difs = xml.dom.minidom.parse(input_dir + "/" + difs_filename)

    debug("Parsing DIFs")

    root = DOM_difs.documentElement
    assert root.tagName == "difs"

    difs_d = DOM_difs.getElementsByTagName("dif")
    for dif in difs_d:
        parse_dif(dif)
    debug("DIF parsing done")

    for dif in difs:
        debug("DIF name: " + dif.name)
        debug("  DIF type: " + dif.dif_type)

    for node in nodes:
        dir_path = output_dir + "/" + node.name
        debug("Putting files in " + dir_path)
        if not os.path.exists(dir_path):
            os.makedirs(dir_path)

        f = open(os.path.join(dir_path, prefix_name + ".conf"),'w')

        str = json.dumps({"localConfiguration" : {
            "installationPath" : "@prefix@/bin",
            "libraryPath" : "@libdir@",
            "logPath" : "@localstatedir@/log",
            "consolePort" : 32766,
            "pluginsPaths" : ["@libdir@/rinad/ipcp"]
        }},indent=4, separators=(',', ': '))

        debug(str)
        #newdoc = impl.createDocument(None, "config", None)
        #root = newdoc.documentElement
        #text = newdoc.createTextNode('We all love Pippo.')
        #root.appendChild(text)
        #newdoc.writexml(f, indent="", addindent="", newl="\n")


except Exception as e:
    error("Got a problem: " + str(e))
    sys.exit(1)

sys.exit(0)
